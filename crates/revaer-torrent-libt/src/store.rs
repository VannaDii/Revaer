use std::collections::HashMap;
use std::ffi::OsStr;
use std::fs;
use std::path::PathBuf;

use chrono::{DateTime, Utc};
use revaer_torrent_core::{
    FilePriorityOverride, FileSelectionRules, StorageMode, TorrentCleanupPolicy, TorrentError,
    TorrentRateLimit, TorrentResult,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::error::{LibtorrentError, op_failed};
const META_SUFFIX: &str = ".meta.json";
const FASTRESUME_SUFFIX: &str = ".fastresume";

/// Persisted metadata companion alongside libtorrent fastresume files.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct StoredTorrentMetadata {
    #[serde(default)]
    /// File selection rules captured at resume time.
    pub selection: FileSelectionRules,
    #[serde(default)]
    /// Per-file priority overrides applied to this torrent.
    pub priorities: Vec<FilePriorityOverride>,
    #[serde(default)]
    /// Optional download directory recorded by the engine.
    pub download_dir: Option<String>,
    #[serde(default)]
    /// Storage allocation mode at admission time.
    pub storage_mode: Option<StorageMode>,
    #[serde(default)]
    /// Whether partfiles were enabled.
    pub use_partfile: Option<bool>,
    #[serde(default)]
    /// Indicates whether sequential download mode was active.
    pub sequential: bool,
    #[serde(default)]
    /// Whether the torrent was added in seed mode.
    pub seed_mode: Option<bool>,
    #[serde(default)]
    /// Percentage of pieces hashed before honoring seed mode.
    pub hash_check_sample_pct: Option<u8>,
    #[serde(default)]
    /// Whether the torrent was added with super-seeding enabled.
    pub super_seeding: Option<bool>,
    #[serde(default)]
    /// Trackers that were supplied when the torrent was added.
    pub trackers: Vec<String>,
    #[serde(default)]
    /// Whether the supplied trackers replaced profile defaults.
    pub replace_trackers: bool,
    #[serde(default)]
    /// Per-tracker status messages (when available).
    pub tracker_messages: std::collections::HashMap<String, String>,
    #[serde(default)]
    /// Web seeds associated with the torrent.
    pub web_seeds: Vec<String>,
    #[serde(default)]
    /// Whether supplied web seeds replaced existing seeds.
    pub replace_web_seeds: bool,
    #[serde(default)]
    /// Tags provided at admission time.
    pub tags: Vec<String>,
    #[serde(default)]
    /// Optional category assigned at admission time.
    pub category: Option<String>,
    #[serde(default)]
    /// Optional comment captured from torrent metainfo.
    pub comment: Option<String>,
    #[serde(default)]
    /// Optional source label captured from torrent metainfo.
    pub source: Option<String>,
    #[serde(default)]
    /// Private flag captured from torrent metainfo.
    pub private: Option<bool>,
    #[serde(default)]
    /// Optional per-torrent peer connection cap recorded at admission.
    pub connections_limit: Option<i32>,
    #[serde(default)]
    /// Optional per-torrent rate caps recorded at admission.
    pub rate_limit: Option<TorrentRateLimit>,
    #[serde(default)]
    /// Optional cleanup policy recorded at admission.
    pub cleanup: Option<TorrentCleanupPolicy>,
    #[serde(default)]
    /// Optional share ratio threshold recorded at admission.
    pub seed_ratio_limit: Option<f64>,
    #[serde(default)]
    /// Optional seeding time limit recorded at admission (seconds).
    pub seed_time_limit: Option<u64>,
    #[serde(default)]
    /// Whether the torrent was auto-managed at admission.
    pub auto_managed: Option<bool>,
    #[serde(default)]
    /// Optional queue position recorded when auto-managed was disabled.
    pub queue_position: Option<i32>,
    #[serde(default)]
    /// Whether peer exchange was enabled for the torrent.
    pub pex_enabled: Option<bool>,
    #[serde(default)]
    /// Timestamp of the most recent metadata update.
    pub updated_at: DateTime<Utc>,
}

/// Combined view of resume payload + metadata for a torrent.
#[derive(Debug, Clone, Default)]
pub struct StoredTorrentState {
    /// Unique torrent identifier.
    pub torrent_id: Uuid,
    /// Raw fastresume payload generated by libtorrent.
    pub fastresume: Option<Vec<u8>>,
    /// Selection metadata persisted alongside the payload.
    pub metadata: Option<StoredTorrentMetadata>,
}

impl StoredTorrentState {
    const fn new(torrent_id: Uuid) -> Self {
        Self {
            torrent_id,
            fastresume: None,
            metadata: None,
        }
    }
}

/// Service responsible for persisting fast-resume data and selection metadata.
#[derive(Clone, Debug)]
pub struct FastResumeStore {
    base_dir: PathBuf,
}

impl FastResumeStore {
    /// Construct a store rooted at the provided directory.
    #[must_use]
    pub fn new(base_dir: impl Into<PathBuf>) -> Self {
        Self {
            base_dir: base_dir.into(),
        }
    }

    /// Ensure the underlying directory exists.
    ///
    /// # Errors
    ///
    /// Returns an error if the directory cannot be created.
    pub fn ensure_initialized(&self) -> TorrentResult<()> {
        if !self.base_dir.exists() {
            fs::create_dir_all(&self.base_dir).map_err(|source| {
                Self::store_io_error("fastresume_init", None, self.base_dir.clone(), source)
            })?;
        }
        Ok(())
    }

    /// Load all known torrents from disk.
    ///
    /// # Errors
    ///
    /// Returns an error if a fastresume payload or metadata file cannot be read or decoded.
    pub fn load_all(&self) -> TorrentResult<Vec<StoredTorrentState>> {
        if !self.base_dir.exists() {
            return Ok(Vec::new());
        }

        let mut map: HashMap<Uuid, StoredTorrentState> = HashMap::new();
        for entry in fs::read_dir(&self.base_dir).map_err(|source| {
            Self::store_io_error("fastresume_load", None, self.base_dir.clone(), source)
        })? {
            let entry = entry.map_err(|source| {
                Self::store_io_error("fastresume_load_entry", None, self.base_dir.clone(), source)
            })?;
            let path = entry.path();
            let Some(file_name) = path.file_name().and_then(OsStr::to_str) else {
                continue;
            };

            if let Some(id) = strip_suffix(file_name, FASTRESUME_SUFFIX) {
                let payload = fs::read(&path).map_err(|source| {
                    Self::store_io_error("fastresume_read", Some(id), path.clone(), source)
                })?;
                map.entry(id)
                    .or_insert_with(|| StoredTorrentState::new(id))
                    .fastresume = Some(payload);
            } else if let Some(id) = strip_suffix(file_name, META_SUFFIX) {
                let data = fs::read_to_string(&path).map_err(|source| {
                    Self::store_io_error("metadata_read", Some(id), path.clone(), source)
                })?;
                let metadata: StoredTorrentMetadata =
                    serde_json::from_str(&data).map_err(|source| {
                        Self::store_parse_error("metadata_parse", Some(id), path.clone(), source)
                    })?;
                map.entry(id)
                    .or_insert_with(|| StoredTorrentState::new(id))
                    .metadata = Some(metadata);
            }
        }

        Ok(map.into_values().collect())
    }

    /// Persist the fastresume payload for a torrent.
    ///
    /// # Errors
    ///
    /// Returns an error if the payload cannot be written.
    pub fn write_fastresume(&self, torrent_id: Uuid, payload: &[u8]) -> TorrentResult<()> {
        self.ensure_initialized()?;
        let path = self.fastresume_path(&torrent_id);
        fs::write(&path, payload).map_err(|source| {
            Self::store_io_error("fastresume_write", Some(torrent_id), path, source)
        })?;
        Ok(())
    }

    /// Persist the outbound metadata for a torrent (selection/priorities/etc.).
    ///
    /// # Errors
    ///
    /// Returns an error if the metadata cannot be encoded or written.
    pub fn write_metadata(
        &self,
        torrent_id: Uuid,
        metadata: &StoredTorrentMetadata,
    ) -> TorrentResult<()> {
        self.ensure_initialized()?;
        let mut metadata = metadata.clone();
        metadata.updated_at = Utc::now();
        let json = serde_json::to_string_pretty(&metadata).map_err(|source| {
            Self::store_parse_error(
                "metadata_encode",
                Some(torrent_id),
                self.metadata_path(&torrent_id),
                source,
            )
        })?;
        let path = self.metadata_path(&torrent_id);
        fs::write(&path, json).map_err(|source| {
            Self::store_io_error("metadata_write", Some(torrent_id), path, source)
        })?;
        Ok(())
    }

    /// Remove persisted state for a torrent.
    ///
    /// # Errors
    ///
    /// Returns an error if the stored files cannot be deleted.
    pub fn remove(&self, torrent_id: Uuid) -> TorrentResult<()> {
        let fastresume_path = self.fastresume_path(&torrent_id);
        if fastresume_path.exists() {
            fs::remove_file(&fastresume_path).map_err(|source| {
                Self::store_io_error(
                    "fastresume_remove",
                    Some(torrent_id),
                    fastresume_path.clone(),
                    source,
                )
            })?;
        }

        let metadata_path = self.metadata_path(&torrent_id);
        if metadata_path.exists() {
            fs::remove_file(&metadata_path).map_err(|source| {
                Self::store_io_error(
                    "metadata_remove",
                    Some(torrent_id),
                    metadata_path.clone(),
                    source,
                )
            })?;
        }

        Ok(())
    }

    fn fastresume_path(&self, torrent_id: &Uuid) -> PathBuf {
        self.base_dir
            .join(format!("{torrent_id}{FASTRESUME_SUFFIX}"))
    }

    fn metadata_path(&self, torrent_id: &Uuid) -> PathBuf {
        self.base_dir.join(format!("{torrent_id}{META_SUFFIX}"))
    }

    fn store_io_error(
        operation: &'static str,
        torrent_id: Option<Uuid>,
        path: PathBuf,
        source: std::io::Error,
    ) -> TorrentError {
        op_failed(
            operation,
            torrent_id,
            LibtorrentError::StoreIo {
                operation,
                path,
                source,
            },
        )
    }

    fn store_parse_error(
        operation: &'static str,
        torrent_id: Option<Uuid>,
        path: PathBuf,
        source: serde_json::Error,
    ) -> TorrentError {
        op_failed(
            operation,
            torrent_id,
            LibtorrentError::StoreParse {
                operation,
                path,
                source,
            },
        )
    }
}

fn strip_suffix(file_name: &str, suffix: &str) -> Option<Uuid> {
    file_name
        .strip_suffix(suffix)
        .and_then(|value| Uuid::parse_str(value).ok())
}

#[cfg(test)]
mod tests {
    use super::*;
    use anyhow::{Result, anyhow};
    use tempfile::TempDir;

    fn sample_metadata() -> StoredTorrentMetadata {
        StoredTorrentMetadata {
            selection: FileSelectionRules {
                include: vec!["**/*.mkv".into()],
                exclude: vec!["**/extras/**".into()],
                skip_fluff: true,
            },
            priorities: vec![FilePriorityOverride {
                index: 0,
                priority: revaer_torrent_core::FilePriority::High,
            }],
            download_dir: Some(".server_root/downloads".into()),
            storage_mode: Some(StorageMode::Sparse),
            use_partfile: Some(true),
            sequential: true,
            seed_mode: Some(true),
            hash_check_sample_pct: Some(10),
            super_seeding: Some(false),
            trackers: vec!["https://tracker.example/announce".into()],
            replace_trackers: true,
            tracker_messages: std::collections::HashMap::new(),
            web_seeds: vec!["https://seed.example/file".into()],
            replace_web_seeds: false,
            tags: vec!["movies".into(), "hd".into()],
            category: Some("cinema".into()),
            comment: Some("release notes".into()),
            source: Some("revaer".into()),
            private: Some(true),
            rate_limit: Some(TorrentRateLimit {
                download_bps: Some(10_000),
                upload_bps: Some(5_000),
            }),
            cleanup: Some(TorrentCleanupPolicy {
                seed_ratio_limit: Some(2.0),
                seed_time_limit: Some(7_200),
                remove_data: true,
            }),
            connections_limit: None,
            seed_ratio_limit: Some(1.0),
            seed_time_limit: Some(3_600),
            auto_managed: Some(true),
            queue_position: Some(5),
            pex_enabled: Some(true),
            updated_at: Utc::now(),
        }
    }

    #[test]
    fn strip_suffix_extracts_uuid() {
        let id = Uuid::new_v4();
        assert_eq!(
            strip_suffix(&format!("{id}{META_SUFFIX}"), META_SUFFIX),
            Some(id)
        );
        assert_eq!(
            strip_suffix(&format!("{id}{FASTRESUME_SUFFIX}"), FASTRESUME_SUFFIX),
            Some(id)
        );
        assert!(strip_suffix("invalid.txt", META_SUFFIX).is_none());
    }

    #[test]
    fn ensure_initialized_creates_directory() -> Result<()> {
        let temp = TempDir::new()?;
        let target = temp.path().join("resume");
        let store = FastResumeStore::new(&target);
        store.ensure_initialized()?;
        assert!(target.exists());
        Ok(())
    }

    #[test]
    fn write_and_load_round_trip() -> Result<()> {
        let temp = TempDir::new()?;
        let store = FastResumeStore::new(temp.path());
        let torrent_id = Uuid::new_v4();

        let metadata = sample_metadata();
        let resume_blob = vec![0_u8, 1, 2, 3];

        store.write_metadata(torrent_id, &metadata)?;
        store.write_fastresume(torrent_id, &resume_blob)?;

        let mut loaded = store.load_all()?;
        assert_eq!(loaded.len(), 1);
        let state = loaded.pop().ok_or_else(|| anyhow!("state missing"))?;
        assert_eq!(state.torrent_id, torrent_id);
        assert_eq!(state.fastresume, Some(resume_blob));
        let stored_meta = state.metadata.ok_or_else(|| anyhow!("metadata missing"))?;
        assert_eq!(stored_meta.selection.include.len(), 1);
        assert_eq!(stored_meta.priorities.len(), 1);
        assert!(stored_meta.sequential);
        assert_eq!(
            stored_meta.trackers,
            vec!["https://tracker.example/announce".to_string()]
        );
        assert!(stored_meta.replace_trackers);
        assert_eq!(
            stored_meta.web_seeds,
            vec!["https://seed.example/file".to_string()]
        );
        assert!(!stored_meta.replace_web_seeds);
        assert_eq!(
            stored_meta.tags,
            vec!["movies".to_string(), "hd".to_string()]
        );
        assert_eq!(stored_meta.auto_managed, Some(true));
        assert_eq!(stored_meta.queue_position, Some(5));
        assert_eq!(stored_meta.pex_enabled, Some(true));
        assert_eq!(stored_meta.seed_mode, Some(true));
        assert_eq!(stored_meta.hash_check_sample_pct, Some(10));
        assert_eq!(stored_meta.seed_ratio_limit, Some(1.0));
        assert_eq!(stored_meta.seed_time_limit, Some(3_600));
        assert!(stored_meta.updated_at <= Utc::now());

        store.remove(torrent_id)?;
        assert!(store.load_all()?.is_empty());

        Ok(())
    }

    #[test]
    fn load_all_returns_empty_for_missing_directory() -> Result<()> {
        let temp = TempDir::new()?;
        let missing = temp.path().join("missing");
        let store = FastResumeStore::new(&missing);
        assert!(store.load_all()?.is_empty());
        Ok(())
    }

    #[test]
    fn load_all_skips_unrecognized_files() -> Result<()> {
        let temp = TempDir::new()?;
        let store = FastResumeStore::new(temp.path());
        fs::write(temp.path().join("readme.txt"), "not a torrent")?;
        let entries = store.load_all()?;
        assert!(entries.is_empty());
        Ok(())
    }

    #[test]
    fn load_all_errors_on_corrupt_metadata() -> Result<()> {
        let temp = TempDir::new()?;
        let store = FastResumeStore::new(temp.path());
        let torrent_id = Uuid::new_v4();
        let meta_path = temp.path().join(format!("{torrent_id}{META_SUFFIX}"));
        fs::write(&meta_path, "not-json")?;

        let err = store
            .load_all()
            .err()
            .ok_or_else(|| anyhow!("expected corrupt metadata error"))?;
        let TorrentError::OperationFailed { source, .. } = err else {
            return Err(anyhow!("expected operation failure"));
        };
        let source = source
            .downcast::<LibtorrentError>()
            .map_err(|_| anyhow!("expected libtorrent error"))?;
        assert!(matches!(*source, LibtorrentError::StoreParse { .. }));
        Ok(())
    }
}
